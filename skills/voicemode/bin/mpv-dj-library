#!/usr/bin/env bash
# mpv-dj-library - Music library indexing for DJ mode
#
# Usage:
#   mpv-dj-library scan [--path <dir>]     Scan music folder and build index
#   mpv-dj-library search <query>          Search tracks by artist/title
#   mpv-dj-library play <id>               Play track by ID
#   mpv-dj-library info <id>               Show track details
#   mpv-dj-library list [--favorites]      List tracks
#   mpv-dj-library favorite <id>           Toggle favorite flag
#   mpv-dj-library stats                   Show library statistics

set -e

# Configuration
LIBRARY_DB="${HOME}/.voicemode/music-library.db"
DEFAULT_MUSIC_PATH="${HOME}/Audio/music"
SUPPORTED_EXTENSIONS="mp3|flac|m4a|wav|ogg|opus"

# Initialize database with schema
init_db() {
    mkdir -p "$(dirname "$LIBRARY_DB")"

    sqlite3 "$LIBRARY_DB" << 'SQL'
-- Tracks table - main index of all audio files
CREATE TABLE IF NOT EXISTS tracks (
    id INTEGER PRIMARY KEY,
    path TEXT UNIQUE NOT NULL,          -- Relative path from music root
    filename TEXT NOT NULL,
    artist TEXT,
    album TEXT,
    title TEXT,
    year INTEGER,
    track_number INTEGER,
    duration INTEGER,                    -- Seconds (if extractable)
    format TEXT,                         -- mp3, flac, etc.

    -- Sidecar tracking
    is_sidecar BOOLEAN DEFAULT 0,        -- True if in a .d folder
    sidecar_type TEXT,                   -- 'stem', 'loop', 'sample', or NULL
    parent_track_id INTEGER,             -- Links stems/loops to their source track

    -- User data
    favorite BOOLEAN DEFAULT 0,
    tags TEXT,                           -- JSON array
    play_count INTEGER DEFAULT 0,
    last_played TIMESTAMP,

    -- Metadata
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    file_mtime INTEGER,                  -- File modification time for change detection

    FOREIGN KEY (parent_track_id) REFERENCES tracks(id)
);

-- Indexes for fast searching
CREATE INDEX IF NOT EXISTS idx_artist ON tracks(artist);
CREATE INDEX IF NOT EXISTS idx_album ON tracks(album);
CREATE INDEX IF NOT EXISTS idx_title ON tracks(title);
CREATE INDEX IF NOT EXISTS idx_favorite ON tracks(favorite);
CREATE INDEX IF NOT EXISTS idx_is_sidecar ON tracks(is_sidecar);
CREATE INDEX IF NOT EXISTS idx_parent_track ON tracks(parent_track_id);

-- Play history
CREATE TABLE IF NOT EXISTS play_history (
    id INTEGER PRIMARY KEY,
    track_id INTEGER NOT NULL,
    played_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    source TEXT DEFAULT 'local',         -- 'local', 'remote', 'stream'
    FOREIGN KEY (track_id) REFERENCES tracks(id)
);

-- Playlists (for future use)
CREATE TABLE IF NOT EXISTS playlists (
    id INTEGER PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS playlist_tracks (
    id INTEGER PRIMARY KEY,
    playlist_id INTEGER NOT NULL,
    track_id INTEGER NOT NULL,
    position INTEGER,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (playlist_id) REFERENCES playlists(id),
    FOREIGN KEY (track_id) REFERENCES tracks(id)
);

-- Music roots for multi-location support
CREATE TABLE IF NOT EXISTS music_roots (
    id INTEGER PRIMARY KEY,
    path TEXT UNIQUE NOT NULL,
    name TEXT,                           -- 'laptop', 'ms2', etc.
    last_scan TIMESTAMP,
    active BOOLEAN DEFAULT 1
);
SQL
    echo "Database initialized at $LIBRARY_DB"
}

# Parse metadata from path structure: Artist/Year-Album/Track.ext
parse_path_metadata() {
    local rel_path="$1"
    local filename=$(basename "$rel_path")
    local dir=$(dirname "$rel_path")

    # Remove extension for title
    local base_name="${filename%.*}"
    local ext="${filename##*.}"

    # Check if this is a sidecar file
    local is_sidecar=0
    local sidecar_type=""
    if [[ "$rel_path" == *".d/"* ]]; then
        is_sidecar=1
        if [[ "$rel_path" == */stems/* ]]; then
            sidecar_type="stem"
        elif [[ "$rel_path" == */loops/* ]]; then
            sidecar_type="loop"
        elif [[ "$rel_path" == */samples/* ]]; then
            sidecar_type="sample"
        else
            sidecar_type="other"
        fi
    fi

    # Parse directory structure
    # Expected: Artist/Year-Album/track
    # Or: Artist/Year-Album/track.d/stems/stem.mp3

    local artist=""
    local album=""
    local year=""
    local track_num=""
    local title="$base_name"

    # Get the main track directory (before any .d folder)
    local main_dir="$dir"
    if [[ "$is_sidecar" == 1 ]]; then
        # Go up from stems/loops/samples folder, then up from .d folder
        main_dir=$(dirname "$dir")  # up from stems/loops
        main_dir=$(dirname "$main_dir")  # up from .d
    fi

    # Parse Artist/Album from path
    local album_dir=$(basename "$main_dir")
    local artist_dir=$(basename "$(dirname "$main_dir")")

    # Handle year-album format (2005-Human_After_All)
    if [[ "$album_dir" =~ ^([0-9]{4})-(.+)$ ]]; then
        year="${BASH_REMATCH[1]}"
        album="${BASH_REMATCH[2]}"
    else
        album="$album_dir"
    fi

    artist="$artist_dir"

    # Parse track number from filename (01-Track_Name or 01 Track Name)
    if [[ "$base_name" =~ ^([0-9]+)[-_\ ](.+)$ ]]; then
        track_num="${BASH_REMATCH[1]}"
        title="${BASH_REMATCH[2]}"
    fi

    # Clean up underscores to spaces
    artist="${artist//_/ }"
    album="${album//_/ }"
    title="${title//_/ }"
    # Also handle dashes in title (from filename like "robot-rock")
    title="${title//-/ }"

    # Output as tab-separated for easy parsing (use _EMPTY_ marker for empty fields)
    printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' \
        "${artist:-_EMPTY_}" "${album:-_EMPTY_}" "${title:-_EMPTY_}" "${year:-_EMPTY_}" \
        "${track_num:-_EMPTY_}" "$ext" "$is_sidecar" "${sidecar_type:-_EMPTY_}"
}

# Scan music directory and build index
cmd_scan() {
    local music_path="$DEFAULT_MUSIC_PATH"

    while [[ $# -gt 0 ]]; do
        case $1 in
            --path)
                music_path="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ ! -d "$music_path" ]]; then
        echo "Error: Music directory not found: $music_path"
        exit 1
    fi

    init_db

    echo "Scanning: $music_path"
    echo "Looking for: $SUPPORTED_EXTENSIONS"
    echo ""

    local count=0
    local sidecar_count=0

    # Find all audio files
    while IFS= read -r -d '' file; do
        local rel_path="${file#$music_path/}"
        local filename=$(basename "$file")
        # Get file modification time (GNU stat uses -c, BSD uses -f)
        local mtime
        mtime=$(stat -c %Y "$file" 2>/dev/null || /usr/bin/stat -f %m "$file" 2>/dev/null || echo 0)

        # Parse metadata from path - use array splitting for reliable empty field handling
        local metadata
        metadata=$(parse_path_metadata "$rel_path")

        # Use mapfile/readarray to split on tabs, preserving empty fields
        local -a fields
        IFS=$'\t' read -ra fields <<< "$metadata"

        # Convert _EMPTY_ markers back to empty strings
        local artist="${fields[0]:-}"
        local album="${fields[1]:-}"
        local title="${fields[2]:-}"
        local year="${fields[3]:-}"
        local track_num="${fields[4]:-}"
        local format="${fields[5]:-}"
        local is_sidecar="${fields[6]:-0}"
        local sidecar_type="${fields[7]:-}"

        [[ "$artist" == "_EMPTY_" ]] && artist=""
        [[ "$album" == "_EMPTY_" ]] && album=""
        [[ "$title" == "_EMPTY_" ]] && title=""
        [[ "$year" == "_EMPTY_" ]] && year=""
        [[ "$track_num" == "_EMPTY_" ]] && track_num=""
        [[ "$sidecar_type" == "_EMPTY_" ]] && sidecar_type=""

        # Find parent track ID for sidecars
        local parent_id="NULL"
        if [[ "$is_sidecar" == 1 ]]; then
            # Get parent track path (the .d folder name without .d)
            local parent_pattern
            parent_pattern=$(echo "$rel_path" | sed 's/\.d\/.*//')

            # Try to find the parent track
            parent_id=$(sqlite3 "$LIBRARY_DB" "SELECT id FROM tracks WHERE path LIKE '${parent_pattern}%' AND is_sidecar = 0 LIMIT 1" 2>/dev/null || echo "NULL")
            [[ -z "$parent_id" ]] && parent_id="NULL"

            sidecar_count=$((sidecar_count + 1))
        fi

        # Escape single quotes for SQL
        local esc_path="${rel_path//\'/\'\'}"
        local esc_filename="${filename//\'/\'\'}"
        local esc_artist="${artist//\'/\'\'}"
        local esc_album="${album//\'/\'\'}"
        local esc_title="${title//\'/\'\'}"

        # Build sidecar_type value
        local sidecar_type_val="NULL"
        [[ -n "$sidecar_type" ]] && sidecar_type_val="'$sidecar_type'"

        # Build year and track values
        local year_val="NULL"
        [[ -n "$year" && "$year" =~ ^[0-9]+$ ]] && year_val="$year"

        local track_num_val="NULL"
        [[ -n "$track_num" && "$track_num" =~ ^[0-9]+$ ]] && track_num_val="$track_num"

        # Insert or update track
        sqlite3 "$LIBRARY_DB" << SQL
INSERT INTO tracks (path, filename, artist, album, title, year, track_number, format, is_sidecar, sidecar_type, parent_track_id, file_mtime)
VALUES ('$esc_path', '$esc_filename', '$esc_artist', '$esc_album', '$esc_title', $year_val, $track_num_val, '$format', $is_sidecar, $sidecar_type_val, $parent_id, $mtime)
ON CONFLICT(path) DO UPDATE SET
    artist = excluded.artist,
    album = excluded.album,
    title = excluded.title,
    year = excluded.year,
    track_number = excluded.track_number,
    format = excluded.format,
    is_sidecar = excluded.is_sidecar,
    sidecar_type = excluded.sidecar_type,
    parent_track_id = excluded.parent_track_id,
    file_mtime = excluded.file_mtime;
SQL

        count=$((count + 1))

        # Progress indicator
        if [[ $((count % 10)) -eq 0 ]]; then
            printf "\rIndexed: %d files..." "$count"
        fi

    done < <(find -L "$music_path" -type f -regextype posix-extended -regex ".*\.($SUPPORTED_EXTENSIONS)" -print0 2>/dev/null || \
             find -L "$music_path" -type f \( -name "*.mp3" -o -name "*.flac" -o -name "*.m4a" -o -name "*.wav" -o -name "*.ogg" -o -name "*.opus" \) -print0)

    printf "\r                              \r"
    echo "Indexed $count files ($sidecar_count sidecars)"
    echo ""

    # Update parent_track_id for sidecars (second pass)
    echo "Linking sidecars to parent tracks..."
    sqlite3 "$LIBRARY_DB" << 'SQL'
UPDATE tracks SET parent_track_id = (
    SELECT t2.id FROM tracks t2
    WHERE t2.is_sidecar = 0
    AND tracks.path LIKE t2.path || '.d/%'
    LIMIT 1
)
WHERE is_sidecar = 1 AND parent_track_id IS NULL;
SQL

    # Show stats
    cmd_stats
}

# Search tracks
cmd_search() {
    local query="$1"
    local include_sidecars=0

    if [[ -z "$query" ]]; then
        echo "Usage: mpv-dj-library search <query>"
        exit 1
    fi

    # Check for --all flag
    if [[ "$2" == "--all" ]]; then
        include_sidecars=1
    fi

    local sidecar_filter="AND is_sidecar = 0"
    [[ "$include_sidecars" == 1 ]] && sidecar_filter=""

    # Search artist, album, and title
    sqlite3 -column -header "$LIBRARY_DB" << SQL
SELECT
    id,
    artist,
    title,
    album,
    format
FROM tracks
WHERE (
    artist LIKE '%$query%'
    OR title LIKE '%$query%'
    OR album LIKE '%$query%'
)
$sidecar_filter
ORDER BY artist, album, track_number
LIMIT 50;
SQL
}

# Play track by ID
cmd_play() {
    local track_id="$1"

    if [[ -z "$track_id" ]]; then
        echo "Usage: mpv-dj-library play <id>"
        exit 1
    fi

    # Get track path
    local track_info
    track_info=$(sqlite3 -separator $'\t' "$LIBRARY_DB" \
        "SELECT path, artist, title FROM tracks WHERE id = $track_id")

    if [[ -z "$track_info" ]]; then
        echo "Error: Track not found with ID: $track_id"
        exit 1
    fi

    IFS=$'\t' read -r path artist title <<< "$track_info"

    local full_path="$DEFAULT_MUSIC_PATH/$path"

    if [[ ! -f "$full_path" ]]; then
        echo "Error: File not found: $full_path"
        exit 1
    fi

    echo "Playing: $artist - $title"

    # Use mpv-dj play command
    local script_dir="$(dirname "$0")"
    "$script_dir/mpv-dj" play "$full_path"

    # Record play in history
    sqlite3 "$LIBRARY_DB" << SQL
INSERT INTO play_history (track_id) VALUES ($track_id);
UPDATE tracks SET play_count = play_count + 1, last_played = CURRENT_TIMESTAMP WHERE id = $track_id;
SQL
}

# Show track info
cmd_info() {
    local track_id="$1"

    if [[ -z "$track_id" ]]; then
        echo "Usage: mpv-dj-library info <id>"
        exit 1
    fi

    sqlite3 -line "$LIBRARY_DB" << SQL
SELECT
    id,
    artist,
    title,
    album,
    year,
    format,
    CASE WHEN is_sidecar THEN 'Yes (' || sidecar_type || ')' ELSE 'No' END as sidecar,
    CASE WHEN favorite THEN 'Yes' ELSE 'No' END as favorite,
    play_count,
    last_played,
    path
FROM tracks
WHERE id = $track_id;
SQL

    # Show sidecars if this is a main track
    local sidecars
    sidecars=$(sqlite3 "$LIBRARY_DB" "SELECT COUNT(*) FROM tracks WHERE parent_track_id = $track_id")
    if [[ "$sidecars" -gt 0 ]]; then
        echo ""
        echo "Associated sidecars: $sidecars"
        sqlite3 -column "$LIBRARY_DB" << SQL
SELECT sidecar_type, filename FROM tracks WHERE parent_track_id = $track_id ORDER BY sidecar_type, filename;
SQL
    fi
}

# List tracks
cmd_list() {
    local filter=""
    local limit=50

    while [[ $# -gt 0 ]]; do
        case $1 in
            --favorites)
                filter="WHERE favorite = 1"
                shift
                ;;
            --all)
                filter=""
                shift
                ;;
            --limit)
                limit="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Default: exclude sidecars
    if [[ -z "$filter" ]]; then
        filter="WHERE is_sidecar = 0"
    elif [[ "$filter" == "WHERE favorite = 1" ]]; then
        filter="WHERE favorite = 1 AND is_sidecar = 0"
    fi

    sqlite3 -column -header "$LIBRARY_DB" << SQL
SELECT
    id,
    artist,
    title,
    album,
    year,
    CASE WHEN favorite THEN '*' ELSE '' END as fav
FROM tracks
$filter
ORDER BY artist, album, track_number
LIMIT $limit;
SQL
}

# Toggle favorite
cmd_favorite() {
    local track_id="$1"

    if [[ -z "$track_id" ]]; then
        echo "Usage: mpv-dj-library favorite <id>"
        exit 1
    fi

    sqlite3 "$LIBRARY_DB" "UPDATE tracks SET favorite = NOT favorite WHERE id = $track_id"

    local is_fav
    is_fav=$(sqlite3 "$LIBRARY_DB" "SELECT favorite FROM tracks WHERE id = $track_id")

    local track_name
    track_name=$(sqlite3 "$LIBRARY_DB" "SELECT artist || ' - ' || title FROM tracks WHERE id = $track_id")

    if [[ "$is_fav" == "1" ]]; then
        echo "Added to favorites: $track_name"
    else
        echo "Removed from favorites: $track_name"
    fi
}

# Show library statistics
cmd_stats() {
    echo "Library Statistics"
    echo "=================="

    sqlite3 "$LIBRARY_DB" << 'SQL'
SELECT
    'Total tracks' as metric,
    COUNT(*) as value
FROM tracks
WHERE is_sidecar = 0
UNION ALL
SELECT
    'Sidecars (stems/loops/samples)',
    COUNT(*)
FROM tracks
WHERE is_sidecar = 1
UNION ALL
SELECT
    'Favorites',
    COUNT(*)
FROM tracks
WHERE favorite = 1
UNION ALL
SELECT
    'Artists',
    COUNT(DISTINCT artist)
FROM tracks
WHERE is_sidecar = 0
UNION ALL
SELECT
    'Albums',
    COUNT(DISTINCT album)
FROM tracks
WHERE is_sidecar = 0 AND album IS NOT NULL AND album != '';
SQL
}

# Main command dispatch
case "${1:-}" in
    scan)
        shift
        cmd_scan "$@"
        ;;
    search)
        shift
        cmd_search "$@"
        ;;
    play)
        cmd_play "$2"
        ;;
    info)
        cmd_info "$2"
        ;;
    list)
        shift
        cmd_list "$@"
        ;;
    favorite)
        cmd_favorite "$2"
        ;;
    stats)
        cmd_stats
        ;;
    *)
        echo "mpv-dj-library - Music library indexing for DJ mode"
        echo ""
        echo "Usage:"
        echo "  mpv-dj-library scan [--path <dir>]     Scan and index music folder"
        echo "  mpv-dj-library search <query>          Search by artist/title/album"
        echo "  mpv-dj-library play <id>               Play track by ID"
        echo "  mpv-dj-library info <id>               Show track details"
        echo "  mpv-dj-library list [--favorites]      List tracks"
        echo "  mpv-dj-library favorite <id>           Toggle favorite flag"
        echo "  mpv-dj-library stats                   Show library statistics"
        echo ""
        echo "Database: $LIBRARY_DB"
        ;;
esac
