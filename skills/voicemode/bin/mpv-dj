#!/usr/bin/env bash
# mpv-dj - Control background music during VoiceMode sessions
#
# Usage:
#   mpv-dj play <file|url> [--chapters <file>]  Start playback
#   mpv-dj mfp <episode>                         Play Music For Programming episode
#   mpv-dj mfp list [--all] [--urls] [--verbose] List available episodes
#   mpv-dj mfp sync-chapters [--force]           Sync chapter files from package
#   mpv-dj status                                Show current track info
#   mpv-dj pause                                 Pause playback
#   mpv-dj resume                                Resume playback
#   mpv-dj next                                  Skip to next chapter
#   mpv-dj prev                                  Go to previous chapter
#   mpv-dj volume <0-100>                        Set volume
#   mpv-dj stop                                  Stop playback
#   mpv-dj raw <json-command>                    Send raw IPC command
#   mpv-dj history                               Show play history
#   mpv-dj favorite [add|list|remove]            Manage favorites

set -e

# Load config file if it exists
CONFIG_FILE="${HOME}/.voicemode/voicemode.env"
[[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"

SOCKET="/tmp/voicemode-mpv.sock"
MFP_BASE_URL="https://datashat.net"
MFP_DIR="${HOME}/.voicemode/music-for-programming"
DATA_DIR="${HOME}/.voicemode/dj"
HISTORY_FILE="${DATA_DIR}/history.json"
FAVORITES_FILE="${DATA_DIR}/favorites.json"
MFP_AUDIO_DIR="${HOME}/.voicemode/audio/podcasts/music-for-programming"
MFP_EPISODES_JSON="${HOME}/Audio/podcasts/music-for-programming/episodes.json"

# Socket wait configuration
SOCKET_TIMEOUT="${MPV_SOCKET_TIMEOUT:-10}"      # Max wait time in seconds
SOCKET_RETRY_DELAY="${MPV_SOCKET_DELAY:-0.1}"   # Delay between retries (seconds)

# Ensure data directory exists
init_data_dir() {
    mkdir -p "$DATA_DIR"
    [[ -f "$HISTORY_FILE" ]] || echo '[]' > "$HISTORY_FILE"
    [[ -f "$FAVORITES_FILE" ]] || echo '[]' > "$FAVORITES_FILE"
}

# Find the plugin's mfp directory containing chapter files
find_plugin_mfp_dir() {
    local script_dir
    script_dir="$(cd "$(dirname "$0")" && pwd)"

    # Relative path from bin/ to mfp/
    local mfp_dir="${script_dir}/../mfp"

    if [[ -d "$mfp_dir" ]]; then
        echo "$(cd "$mfp_dir" && pwd)"
        return 0
    fi

    return 1
}

# Check if mpv is installed
check_mpv() {
    if ! command -v mpv &> /dev/null; then
        echo "Error: mpv is not installed. Install with: brew install mpv"
        exit 1
    fi
}

# Check if socat is installed (for IPC)
check_socat() {
    if ! command -v socat &> /dev/null; then
        echo "Error: socat is not installed. Install with: brew install socat"
        exit 1
    fi
}

# Check if mpv is running with our socket
is_running() {
    [ -S "$SOCKET" ] && echo '{"command": ["get_property", "pid"]}' | socat - "$SOCKET" 2>/dev/null | grep -q '"error":"success"'
}

# Send IPC command and get response
send_cmd() {
    if ! is_running; then
        echo "Error: DJ is not running. Start with: mpv-dj play <file>"
        exit 1
    fi
    echo "$1" | socat - "$SOCKET"
}

# Wait for mpv socket to become ready
# Returns: 0 on success, 1 on timeout
wait_for_socket() {
    local max_attempts=$((SOCKET_TIMEOUT * 10))  # 10 attempts per second
    local attempt=0

    while [[ $attempt -lt $max_attempts ]]; do
        if is_running; then
            return 0
        fi
        sleep "$SOCKET_RETRY_DELAY"
        ((attempt++))
    done

    echo "Error: mpv socket not ready after ${SOCKET_TIMEOUT}s" >&2
    return 1
}

# Start mpv with IPC socket
cmd_play() {
    check_mpv

    local source=""
    local chapters_file=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --chapters)
                chapters_file="$2"
                shift 2
                ;;
            *)
                source="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$source" ]]; then
        echo "Usage: mpv-dj play <file|url> [--chapters <file>]"
        exit 1
    fi

    # Stop existing playback
    if is_running; then
        send_cmd '{"command": ["quit"]}' > /dev/null 2>&1 || true
        sleep 0.5
    fi

    # Build mpv command
    local mpv_args=(
        --no-video
        --input-ipc-server="$SOCKET"
        --volume="${VOICEMODE_DJ_VOLUME:-50}"
    )

    if [[ -n "$chapters_file" && -f "$chapters_file" ]]; then
        mpv_args+=(--chapters-file="$chapters_file")
    fi

    # Start mpv in background
    mpv "${mpv_args[@]}" "$source" &> /dev/null &

    # Wait for socket to be ready
    if ! wait_for_socket; then
        echo "Failed to start mpv - socket not ready"
        exit 1
    fi

    echo "Started playback: $source"
    if [[ -n "$chapters_file" ]]; then
        echo "Chapters loaded from: $chapters_file"
    fi
}

# Start mpv with stream recording (for caching)
cmd_play_and_cache() {
    check_mpv

    local source=""
    local cache_file=""
    local chapters_file=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --chapters)
                chapters_file="$2"
                shift 2
                ;;
            *)
                if [[ -z "$source" ]]; then
                    source="$1"
                else
                    cache_file="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$source" || -z "$cache_file" ]]; then
        echo "Error: cmd_play_and_cache requires source and cache_file"
        exit 1
    fi

    # Stop existing playback
    if is_running; then
        send_cmd '{"command": ["quit"]}' > /dev/null 2>&1 || true
        sleep 0.5
    fi

    # Build mpv command
    local mpv_args=(
        --no-video
        --input-ipc-server="$SOCKET"
        --stream-record="$cache_file"
    )

    if [[ -n "$chapters_file" && -f "$chapters_file" ]]; then
        mpv_args+=(--chapters-file="$chapters_file")
    fi

    # Start mpv in background
    echo "Caching to: $cache_file"
    mpv "${mpv_args[@]}" "$source" &> /dev/null &

    echo "Started playback: $source"
    if [[ -n "$chapters_file" ]]; then
        echo "Chapters loaded from: $chapters_file"
    fi
}

# Get MFP episode info from episodes.json
get_mfp_episode_info() {
    local episode="$1"

    if [[ ! -f "$MFP_EPISODES_JSON" ]]; then
        echo ""
        return
    fi

    python3 << PYTHON
import json
from pathlib import Path

try:
    data = json.loads(Path("$MFP_EPISODES_JSON").read_text())
    episodes = data.get("episodes", [])
    for ep in episodes:
        if ep.get("number") == $episode:
            url = ep.get("enclosure", {}).get("url", "")
            title = ep.get("title", "")
            print(f"{url}|{title}")
            break
except Exception:
    pass
PYTHON
}

# Play Music For Programming episode
cmd_mfp() {
    local episode="$1"

    if [[ -z "$episode" ]]; then
        echo "Usage: mpv-dj mfp <episode-number>"
        exit 1
    fi

    # Get the correct URL from RSS feed via helper script
    local helper_script="$(dirname "$0")/mfp-rss-helper"
    local stream_url
    local filename_base

    if [[ ! -x "$helper_script" ]]; then
        echo "Error: mfp-rss-helper not found at $helper_script"
        exit 1
    fi

    # Ensure audio directory exists
    mkdir -p "$MFP_AUDIO_DIR"
    mkdir -p "$CHAPTERS_DIR"

    stream_url=$("$helper_script" "$episode")
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to get URL for episode $episode"
        echo "$stream_url"
        exit 1
    fi

    # Get the RSS-based filename for chapter file lookup
    filename_base=$("$helper_script" filename "$episode")
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to get filename for episode $episode"
        echo "$filename_base"
        exit 1
    fi

    # Check for local chapters file using RSS-based naming
    local chapters_file="${MFP_DIR}/${filename_base}.ffmeta"

    mkdir -p "$MFP_DIR"

    # On-demand copy: if chapters file doesn't exist locally, copy from plugin
    if [[ ! -f "$chapters_file" ]]; then
        local plugin_mfp_dir
        if plugin_mfp_dir=$(find_plugin_mfp_dir); then
            local source_file="${plugin_mfp_dir}/${filename_base}.ffmeta"
            if [[ -f "$source_file" ]]; then
                if cp "$source_file" "$chapters_file" 2>/dev/null; then
                    echo "Copied chapter file from package"
                fi
            fi
        fi
    fi

    # Check for local audio file (multiple possible locations)
    local padded_ep=$(printf "%03d" "$episode")
    local local_file=""

    # Check ~/.voicemode/audio location
    local voicemode_file=$(find "$MFP_AUDIO_DIR" -maxdepth 1 -name "${padded_ep}_*.mp3" 2>/dev/null | head -1)

    # Check ~/Audio/podcasts location
    local audio_file=$(find "${HOME}/Audio/podcasts/music-for-programming" -maxdepth 1 -name "${padded_ep}_*.mp3" 2>/dev/null | head -1)

    if [[ -n "$voicemode_file" && -f "$voicemode_file" ]]; then
        local_file="$voicemode_file"
        echo "Playing local file: $(basename "$local_file")"
    elif [[ -n "$audio_file" && -f "$audio_file" ]]; then
        local_file="$audio_file"
        echo "Playing local file: $(basename "$local_file")"
    fi

    if [[ -n "$local_file" ]]; then
        # Play local file
        record_history "mfp" "$episode" "$local_file"

        if [[ -f "$chapters_file" ]]; then
            cmd_play "$local_file" --chapters "$chapters_file"
        else
            echo "Note: No chapters file. Generate with: audio mfp chapters $episode"
            cmd_play "$local_file"
        fi
    else
        # Stream from web (with caching)
        local ep_info=$(get_mfp_episode_info "$episode")

        if [[ -n "$ep_info" ]]; then
            local stream_url=$(echo "$ep_info" | cut -d'|' -f1)
            local title=$(echo "$ep_info" | cut -d'|' -f2)
            echo "Streaming: $title"
        else
            # Fallback URL pattern
            local stream_url="${MFP_BASE_URL}/music_for_programming_${episode}-unknown.mp3"
            echo "Note: Episode info not found, trying generic URL"
        fi

        record_history "mfp" "$episode" "$stream_url"

        # Cache the stream for future playback
        local cache_file="${MFP_AUDIO_DIR}/${padded_ep}_Episode_${episode}.mp3"

        if [[ -f "$chapters_file" ]]; then
            cmd_play_and_cache "$stream_url" "$cache_file" --chapters "$chapters_file"
        else
            echo "Note: No chapters file. Generate with: audio mfp chapters $episode"
            cmd_play_and_cache "$stream_url" "$cache_file"
        fi
    fi
}

# List available MFP episodes
cmd_mfp_list() {
    local helper_script="$(dirname "$0")/mfp-rss-helper"

    if [[ ! -x "$helper_script" ]]; then
        echo "Error: mfp-rss-helper not found at $helper_script"
        exit 1
    fi

    local args=("list")

    # Detect if stdout is terminal - use human format for terminal, tsv for pipes
    if [[ -t 1 ]]; then
        args+=("--format=human")
    else
        args+=("--format=tsv")
    fi

    # Pass through supported flags
    for arg in "$@"; do
        case "$arg" in
            --urls|--all|--verbose)
                args+=("$arg")
                ;;
        esac
    done

    "$helper_script" "${args[@]}"
}

# Sync a single chapter file with conflict resolution
# Usage: sync_chapter_file <source> <dest> <pkg_checksums> <local_checksums> <force>
sync_chapter_file() {
    local source="$1"
    local dest="$2"
    local pkg_checksums="$3"
    local local_checksums="$4"
    local force="$5"

    local filename
    filename=$(basename "$source")

    # If destination doesn't exist, simple copy
    if [[ ! -f "$dest" ]]; then
        cp "$source" "$dest"
        echo "  Added: $filename"
        return
    fi

    # Calculate current checksums
    local source_sha dest_sha
    source_sha=$(LC_ALL=C shasum -a 256 "$source" | cut -d' ' -f1)
    dest_sha=$(LC_ALL=C shasum -a 256 "$dest" | cut -d' ' -f1)

    # If identical, skip
    if [[ "$source_sha" == "$dest_sha" ]]; then
        echo "  Unchanged: $filename"
        return
    fi

    # Get last known package checksum (from previous sync)
    local last_pkg_sha=""
    if [[ -f "$local_checksums" ]]; then
        last_pkg_sha=$(grep "$filename" "$local_checksums" 2>/dev/null | cut -d' ' -f1 || true)
    fi

    # Determine if user modified the file
    local user_modified=false
    if [[ -n "$last_pkg_sha" && "$dest_sha" != "$last_pkg_sha" ]]; then
        user_modified=true
    fi

    if [[ "$user_modified" == true && "$force" != true ]]; then
        # User modified - backup and update
        cp "$dest" "${dest}.user"
        cp "$source" "$dest"
        echo "  Updated: $filename (user version saved as .user)"
    else
        # Not modified or force - overwrite
        cp "$source" "$dest"
        echo "  Updated: $filename"
    fi
}

# Sync all chapter files from plugin to user directory
# Usage: mpv-dj mfp sync-chapters [--force]
cmd_mfp_sync_chapters() {
    local force=false
    [[ "$1" == "--force" ]] && force=true

    local plugin_mfp_dir
    if ! plugin_mfp_dir=$(find_plugin_mfp_dir); then
        echo "Error: Could not find plugin mfp directory"
        exit 1
    fi

    mkdir -p "$MFP_DIR"

    local checksums_file="${plugin_mfp_dir}/chapters.sha256"
    local local_checksums="${MFP_DIR}/.chapters.sha256"

    echo "Syncing chapter files from package..."

    # Process each ffmeta file in plugin directory
    local count=0
    for source_file in "$plugin_mfp_dir"/*.ffmeta; do
        [[ -f "$source_file" ]] || continue

        local filename
        filename=$(basename "$source_file")
        local dest_file="${MFP_DIR}/${filename}"

        sync_chapter_file "$source_file" "$dest_file" "$checksums_file" "$local_checksums" "$force"
        ((count++)) || true
    done

    # Update local checksums cache
    if [[ -f "$checksums_file" ]]; then
        cp "$checksums_file" "$local_checksums"
    fi

    echo "Chapter sync complete ($count files processed)"
}

# Record play event in history
record_history() {
    init_data_dir
    local type="$1"
    local identifier="$2"
    local source="$3"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Use Python for JSON manipulation (more reliable than jq dependency)
    python3 << PYTHON
import json
from pathlib import Path

history_file = Path("$HISTORY_FILE")
history = json.loads(history_file.read_text())

# Add new entry
entry = {
    "type": "$type",
    "identifier": "$identifier",
    "source": "$source",
    "timestamp": "$timestamp"
}
history.append(entry)

# Keep last 100 entries
history = history[-100:]

history_file.write_text(json.dumps(history, indent=2))
PYTHON
}

# Show play history
cmd_history() {
    init_data_dir
    local limit="${1:-10}"

    if [[ ! -s "$HISTORY_FILE" ]] || [[ $(cat "$HISTORY_FILE") == "[]" ]]; then
        echo "No play history yet"
        exit 0
    fi

    echo "Play History (last $limit):"
    echo "=========================="

    python3 << PYTHON
import json
from pathlib import Path
from datetime import datetime

history_file = Path("$HISTORY_FILE")
history = json.loads(history_file.read_text())

# Show most recent first
for entry in reversed(history[-$limit:]):
    ts = entry.get("timestamp", "")
    if ts:
        dt = datetime.fromisoformat(ts.replace("Z", "+00:00"))
        ts_str = dt.strftime("%Y-%m-%d %H:%M")
    else:
        ts_str = "unknown"

    entry_type = entry.get("type", "unknown")
    identifier = entry.get("identifier", "")

    if entry_type == "mfp":
        print(f"  {ts_str}  MFP Episode {identifier}")
    else:
        print(f"  {ts_str}  {entry.get('source', 'unknown')}")
PYTHON
}

# Manage favorites
cmd_favorite() {
    init_data_dir
    local action="${1:-list}"

    case "$action" in
        add)
            add_favorite
            ;;
        list)
            list_favorites
            ;;
        remove)
            remove_favorite "$2"
            ;;
        *)
            echo "Usage: mpv-dj favorite [add|list|remove <index>]"
            exit 1
            ;;
    esac
}

# Add current track to favorites
add_favorite() {
    if ! is_running; then
        echo "Error: DJ is not running. Play something first."
        exit 1
    fi

    # Get current track info
    local chapter_meta=$(send_cmd '{"command": ["get_property", "chapter-metadata"]}')
    local time_pos=$(send_cmd '{"command": ["get_property", "time-pos"]}')
    local path=$(send_cmd '{"command": ["get_property", "path"]}')

    local title=$(echo "$chapter_meta" | grep -o '"TITLE":"[^"]*"' | cut -d'"' -f4)
    local pos=$(echo "$time_pos" | grep -o '"data":[0-9.]*' | cut -d':' -f2)
    local source=$(echo "$path" | grep -o '"data":"[^"]*"' | cut -d'"' -f4)

    if [[ -z "$title" ]]; then
        title="Unknown track"
    fi

    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    python3 << PYTHON
import json
from pathlib import Path

favorites_file = Path("$FAVORITES_FILE")
favorites = json.loads(favorites_file.read_text())

# Add new favorite
entry = {
    "title": "$title",
    "source": "$source",
    "position": $pos,
    "added": "$timestamp"
}
favorites.append(entry)

favorites_file.write_text(json.dumps(favorites, indent=2))
print(f"Added to favorites: $title")
PYTHON
}

# List favorites
list_favorites() {
    if [[ ! -s "$FAVORITES_FILE" ]] || [[ $(cat "$FAVORITES_FILE") == "[]" ]]; then
        echo "No favorites yet. Use 'mpv-dj favorite add' while playing a track."
        exit 0
    fi

    echo "Favorites:"
    echo "=========="

    python3 << PYTHON
import json
from pathlib import Path

favorites_file = Path("$FAVORITES_FILE")
favorites = json.loads(favorites_file.read_text())

for i, fav in enumerate(favorites, 1):
    title = fav.get("title", "Unknown")
    pos = fav.get("position", 0)
    pos_min = int(pos) // 60
    pos_sec = int(pos) % 60
    print(f"  [{i}] {title} (at {pos_min}:{pos_sec:02d})")
PYTHON
}

# Remove favorite by index
remove_favorite() {
    local index="$1"
    if [[ -z "$index" ]]; then
        echo "Usage: mpv-dj favorite remove <index>"
        exit 1
    fi

    python3 << PYTHON
import json
from pathlib import Path

favorites_file = Path("$FAVORITES_FILE")
favorites = json.loads(favorites_file.read_text())

try:
    idx = int("$index") - 1
    if 0 <= idx < len(favorites):
        removed = favorites.pop(idx)
        favorites_file.write_text(json.dumps(favorites, indent=2))
        print(f"Removed: {removed.get('title', 'Unknown')}")
    else:
        print(f"Invalid index: $index")
except ValueError:
    print(f"Invalid index: $index")
PYTHON
}

# Get current status
cmd_status() {
    check_socat

    if ! is_running; then
        echo "DJ is not running"
        exit 0
    fi

    local chapter_meta=$(send_cmd '{"command": ["get_property", "chapter-metadata"]}')
    local time_pos=$(send_cmd '{"command": ["get_property", "time-pos"]}')
    local duration=$(send_cmd '{"command": ["get_property", "duration"]}')
    local volume=$(send_cmd '{"command": ["get_property", "volume"]}')
    local paused=$(send_cmd '{"command": ["get_property", "pause"]}')

    # Parse JSON responses
    local title=$(echo "$chapter_meta" | grep -o '"TITLE":"[^"]*"' | cut -d'"' -f4)
    local pos=$(echo "$time_pos" | grep -o '"data":[0-9.]*' | cut -d':' -f2)
    local dur=$(echo "$duration" | grep -o '"data":[0-9.]*' | cut -d':' -f2)
    local vol=$(echo "$volume" | grep -o '"data":[0-9.]*' | cut -d':' -f2)
    local is_paused=$(echo "$paused" | grep -o '"data":true')

    echo "DJ Status"
    echo "========="
    if [[ -n "$title" ]]; then
        echo "Track: $title"
    else
        echo "Track: (no chapter metadata)"
    fi

    if [[ -n "$pos" && -n "$dur" ]]; then
        # Convert to integers for time formatting
        local pos_int=${pos%.*}
        local dur_int=${dur%.*}
        local pos_min=$((pos_int / 60))
        local pos_sec=$((pos_int % 60))
        local dur_min=$((dur_int / 60))
        local dur_sec=$((dur_int % 60))
        printf "Position: %d:%02d / %d:%02d\n" "$pos_min" "$pos_sec" "$dur_min" "$dur_sec"
    fi

    if [[ -n "$vol" ]]; then
        echo "Volume: ${vol%.*}%"
    fi

    if [[ -n "$is_paused" ]]; then
        echo "State: Paused"
    else
        echo "State: Playing"
    fi
}

# Pause playback
cmd_pause() {
    send_cmd '{"command": ["set_property", "pause", true]}' > /dev/null
    echo "Paused"
}

# Resume playback
cmd_resume() {
    send_cmd '{"command": ["set_property", "pause", false]}' > /dev/null
    echo "Resumed"
}

# Next chapter
cmd_next() {
    send_cmd '{"command": ["add", "chapter", 1]}' > /dev/null
    sleep 0.3
    cmd_status
}

# Previous chapter
cmd_prev() {
    send_cmd '{"command": ["add", "chapter", -1]}' > /dev/null
    sleep 0.3
    cmd_status
}

# Set volume
cmd_volume() {
    local vol="$1"
    if [[ -z "$vol" ]] || [[ ! "$vol" =~ ^[0-9]+$ ]] || [[ "$vol" -lt 0 ]] || [[ "$vol" -gt 100 ]]; then
        echo "Usage: mpv-dj volume <0-100>"
        exit 1
    fi
    send_cmd "{\"command\": [\"set_property\", \"volume\", $vol]}" > /dev/null
    echo "Volume set to ${vol}%"
}

# Stop playback
cmd_stop() {
    if is_running; then
        send_cmd '{"command": ["quit"]}' > /dev/null 2>&1 || true
        echo "Stopped"
    else
        echo "DJ is not running"
    fi
}

# Raw IPC command
cmd_raw() {
    check_socat
    local cmd="$1"
    if [[ -z "$cmd" ]]; then
        echo "Usage: mpv-dj raw '<json-command>'"
        exit 1
    fi
    send_cmd "$cmd"
}

# Main command dispatch
case "${1:-}" in
    play)
        shift
        cmd_play "$@"
        ;;
    mfp)
        case "$2" in
            list)
                shift 2  # Remove 'mfp' and 'list'
                cmd_mfp_list "$@"
                ;;
            sync-chapters)
                cmd_mfp_sync_chapters "$3"
                ;;
            *)
                cmd_mfp "$2"
                ;;
        esac
        ;;
    status)
        cmd_status
        ;;
    pause)
        cmd_pause
        ;;
    resume)
        cmd_resume
        ;;
    next)
        cmd_next
        ;;
    prev)
        cmd_prev
        ;;
    volume)
        cmd_volume "$2"
        ;;
    stop)
        cmd_stop
        ;;
    raw)
        cmd_raw "$2"
        ;;
    history)
        cmd_history "$2"
        ;;
    favorite)
        shift
        cmd_favorite "$@"
        ;;
    library)
        # Delegate to mpv-dj-library script
        shift
        exec "$(dirname "$0")/mpv-dj-library" "$@"
        ;;
    *)
        echo "mpv-dj - Background music for VoiceMode sessions"
        echo ""
        echo "Usage:"
        echo "  mpv-dj play <file|url> [--chapters <file>]  Start playback"
        echo "  mpv-dj mfp <episode>                         Play Music For Programming"
        echo "  mpv-dj mfp list [--all] [--urls] [--verbose] List available episodes"
        echo "  mpv-dj mfp sync-chapters [--force]           Sync chapter files from package"
        echo "  mpv-dj status                                Show current track"
        echo "  mpv-dj pause                                 Pause playback"
        echo "  mpv-dj resume                                Resume playback"
        echo "  mpv-dj next                                  Next chapter"
        echo "  mpv-dj prev                                  Previous chapter"
        echo "  mpv-dj volume <0-100>                        Set volume"
        echo "  mpv-dj stop                                  Stop playback"
        echo "  mpv-dj history [limit]                       Show play history"
        echo "  mpv-dj favorite [add|list|remove <idx>]      Manage favorites"
        echo "  mpv-dj library <command>                     Music library (scan, search, play)"
        echo "  mpv-dj raw '<json>'                          Send raw IPC command"
        ;;
esac
